[["index.html", "Kungfu Pandas Lời nói đầu Giới thiệu cuốn sách Giới thiệu tác giả", " Kungfu Pandas Lê Huỳnh Đức 2021-06-08 Lời nói đầu Giới thiệu cuốn sách Giới thiệu tác giả "],["cấu-trúc-và-kiểu-dữ-liệu.html", "Chương 1 Cấu trúc và kiểu dữ liệu 1.1 Series 1.2 DataFrame 1.3 Data type trong pandas", " Chương 1 Cấu trúc và kiểu dữ liệu Mục tiêu của chương này nhằm giới thiệu về các cấu trúc cơ bản trong Pandas là Series và DataFrame. Trong chương này, bạn sẽ học cách khởi tạo các cấu trúc này cũng như một số thao tác cơ bản trên Series. Bạn cũng sẽ được biết về một số kiểu dữ liệu thường gặp trong pandas và cách để giảm thiểu bộ nhớ sử dụng khi khởi tạo dữ liệu. 1.1 Series Trong Pandas, Series là mảng 1 chiều bao gồm một danh sách giá trị, và một mảng chứa index của các giá trị. Trong dữ liệu dảng bảng, mỗi Series được xem như là một cột của bảng đó. Cách đơn giản để tạo Series như sau s = pd.Series(data, index=None, name=None) Trong đó data có thể có dạng: numpy.ndarray, List Python dict Scalar index có thể truyền hoặc không, tùy vào dạng của data mà index sẽ được định nghĩa khác nhau. name là tên của Series, giá trị này cũng không nhất thiết phải truyền vào. 1.1.1 Các cách khởi tạo Khởi tạo Series bằng array Khi không truyền giá trị index, Series sẽ mặc định index của nó là 1 mảng số nguyên từ 0 đến len(data) - 1 In [1]: pd.Series(data=[0, 1, 2], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], name=&quot;meow&quot;) Out[1]: a 0 b 1 c 2 Name: meow, dtype: int64 Khởi tạo Series bằng dict In [1]: pd.Series({&quot;b&quot;: 1, &quot;a&quot;:0, &quot;c&quot;: 2}) Out[1]: b 1 a 0 c 2 dtype: int64 Lưu ý: Trong trường hợp bạn truyền biến index vào, Series sẽ đánh index dựa vào thứ tự trong index, và chỉ chứa các giá trị của dict có key nằm trong index. Với các giá trị trong biến index không có trong keys của dict, Series sẽ tạo ra các giá trị bị thiếu NaN. In [1]: pd.Series({&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2, &quot;e&quot;: 4}, index=[&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]) Out[1]: b 1.0 c 2.0 d NaN a 0.0 dtype: float64 Lưu ý: NaN là giá trị mặc định cho dữ liệu bị thiếu trong pandas và giá trị này có kiểu là float64 nên kiểu dữ liệu của Series cũng là float64 khác với int64 ở ví dụ trước đó. Khởi tạo Series bằng một giá trị (Scalar) In [1]: pd.Series(data=1, index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) Out[1]: a 1 b 1 c 1 dtype: int64 1.1.2 Một số thao tác cơ bản Thao tác trên Series cũng giống với thao tác trên numpy.array. Ngoài ra chúng ta còn có thể tác với Series dựa vào index Ví dụ: In [1]: s = pd.Series(data=[0, 1, 2, 3, 4, 5], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]) Hiển thị toàn bộ giá trị của Series Ta gọi thuộc tính .values In [1]: s.values Out[1]: array([0, 1, 2, 3, 4, 5]) Lấy theo indice In [2]: s[2] Out[2]: 2 Lấy theo index In [3]: s[&quot;c&quot;] Out[3]: 2 Slice indice In [4]: s[1:3] Out[4]: b 1 d 2 dtype: int64 Slice index In [5]: s[&quot;b&quot;:&quot;c&quot;] Out[5]: b 1 c 2 dtype: int64 List indice In [6]: s[[1, 2, 4]] Out[6]: b 1 c 2 e 4 dtype: int64 List index In [7]: s[[&quot;b&quot;, &quot;c&quot;, &quot;e&quot;]] Out[7]: b 1 c 2 e 4 dtype: int64 Điều kiện In [5]: s[s &gt; s.mean()] Out[5]: d 3 e 4 f 5 dtype: int64 1.2 DataFrame DataFrame là cấu trúc dữ liệu chính và cũng là đặc trưng của pandas. Cũng giống như SQL Table, DataFrame là một bảng gồm một hay nhiều cột dữ liệu. Hoặc có thể nói rõ hơn là DataFrame là tập hợp các Series lại với nhau. Cách khởi tạo DataFrame như sau df = pd.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) Cũng giống như Series, data của DataFrame có nhiều cách khởi tạo khác nhau như: dict của Series, dict của numpy.array/List Mảng 2 chiều numpy.ndarray, List của List Mảng có cấu trúc Từ 1 Series Từ DataFrame khác Tùy vào cấu trúc của data mà chúng ta có thể bỏ qua biến index. Biến columns thể hiện tên của các Series. dtype sẽ định nghĩa các kiểu dữ liệu của dữ liệu, chúng ta sẽ thảo luận về nó ở phần kế tiếp của chương này. copy dùng để tạo bản sao từ dữ liệu data, nó chỉ ảnh hưởng khi data là DataFrame khác hoặc numpy.ndarray, việc copy này sẽ tránh trường hợp 2 biến cùng trỏ về cùng 1 bộ nhớ. 1.2.1 Các cách khởi tạo Khởi tạo DataFrame từ dict của Series Khi không truyền biến index vào, thì index của DataFrame sẽ là hợp giữa 2 index của Series và chúng sẽ được sắp xếp theo thứ tự từ vựng. Nếu ta không truyền columns thì các cột của DataFrame sẽ được sắp xếp theo thứ tự truyền vào các keys của dict. Khi truyền biến index vào, tương tự như Series, chỉ những index nằm trong index mới được chọn, còn những index bị thiếu sẽ được điền giá trị NaN Khi truyền giá trị columns, DataFrame sẽ chọn những Series thuộc dict có key thuộc columns, giá trị trong columns không có trong key của dict sẽ được gán NaN In [1]: d = { &quot;one&quot;: pd.Series([1, 2, 3], index=[&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]), &quot;two&quot;: pd.Series([1, 2, 3, 4], index=[&quot;c&quot;, &quot;a&quot;, &quot;b&quot;, &quot;d&quot;]) } In [2]: pd.DataFrame(d) Out[2]: one two a 3.0 2 b 2.0 3 c 1.0 1 d NaN 4 In [3]: pd.DataFrame(d, index=[&quot;d&quot;, &quot;b&quot;, &quot;a&quot;]) Out[3]: one two d NaN 4 b 2.0 3 a 3.0 2 In [4]: pd.DataFrame(d, index=[&quot;d&quot;, &quot;b&quot;, &quot;a&quot;], columns=[&quot;two&quot;, &quot;three&quot;]) Out[4]: two three d 4 NaN b 3 NaN a 2 NaN Khởi tạo DataFrame từ dict của numpy.ndarray/List Đối với việc khởi tạo này, bắt buộc các mảng phải có cùng độ dài. Khi không truyền index vào thì index của DataFrame sẽ được tạo từ 0 đến len(n) - 1 trong đó n là độ dài của mảng. Khi truyền giá trị columns, DataFrame sẽ chọn những key thuộc dict và cũng thuộc columns, giá trị trong columns không có trong key của dict sẽ được gán NaN In [1]: d = { &quot;one&quot;: [1, 2, 3, 4], &quot;two&quot;: [1, 2, 3, 4], &quot;three&quot;: [1, 2, 3, 4] } In [2]: pd.DataFrame(data=d, index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], columns=[&quot;one&quot;, &quot;two&quot;, &quot;four&quot;]) Out[2]: one two four a 1 1 NaN b 2 2 NaN c 3 3 NaN d 4 4 NaN Khởi tạo DataFrame từ Mảng 2 chiều/ 2-d numpy.ndarray Khi không truyền index vào thì index của DataFrame sẽ được tạo từ 0 đến len(n) - 1 trong đó n là số lượng List con hoặc là số dòng hay shape[0] của numpy.ndarray. Khi không truyền columns thì tên columns sẽ được tạo từ 0 đến len(n) - 1 với n là độ dài lớn nhất của List con hoặc shape[1] của numpy.ndarray In [1]: pd.DataFrame(data=[[1, 2], [3, 4, 5]], index=[&quot;a&quot;, &quot;b&quot;], columns=[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;]) Out[1]: one two three a 1 2 NaN b 3 4 5.0 In [2]: pd.DataFrame(data=np.random.rand(2,3), index=[&quot;a&quot;, &quot;b&quot;], columns=[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;])) Out[2]: one two three a 0.662008 0.085735 0.331281 b 0.115360 0.358092 0.862477 Khởi tạo DataFrame từ danh sách các dict Ở cách khởi tạo này, bạn hãy tưởng tượng rằng mỗi dict là một dòng của DataFrame với các key là tên cột và value là giá trị tại cột đó. Việc truyền thêm hoặc không truyền index cũng giống như các trường hợp khởi tạo trên. Lưu ý: Trong trường hợp này, nếu bạn truyền columns vào thì columns bắt buộc phải chứa tất cả các key của dict Trong ví dụ dưới đây, columns phải chứa toàn bộ keys [\"one\", \"two\", \"three\"], nếu thiếu 1 trong 3 sẽ phát sinh lỗi. In [1]: d = [{&quot;one&quot;: 1, &quot;two&quot;: 2}, {&quot;one&quot;: 4, &quot;two&quot;: 5, &quot;three&quot;: 6}] In [2]: pd.DataFrame(d, index=[&quot;a&quot;, &quot;b&quot;], columns=[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]) Out[2]: one two three four a 1 2 NaN NaN b 4 5 6.0 NaN Khởi tạo DataFrame từ Mảng có cấu trúc Mảng có cấu trúc là mảng mà các phần tử của nó là một cấu trúc, bao gồm các thành phần nhỏ hơn, các thành phần này được đặt tên và khai báo kiểu dữ liệu. Dưới đây là một ví dụ Mảng có cấu trúc trong numpy In [1]: data = np.array([(&#39;pikachu&#39;, 9, 27.0), (&#39;mewtwo&#39;, 3, 81.0)], dtype=[(&#39;name&#39;, &#39;U10&#39;), (&#39;age&#39;, &#39;i4&#39;), (&#39;weight&#39;, &#39;f4&#39;)]) In [2]: pd.DataFrame(data) Out[2]: name age weight 0 pikachu 9 27.0 1 mewtwo 3 81.0 Khởi tạo DataFrame từ namedtuple Các trường trong nametuple sẽ được gán thành tên các columns trong DataFrame. Những giá trị của namedtuple sẽ được xem là 1 dòng trong DataFrame. Số lượng cột của DataFrame sẽ phụ thuộc vào số lượng giá trị của phần từ namedtuple đầu tiên. Nếu các phần tử phía sau có số lượng giá trị ít hơn thì sẽ được điền NaN và ngược lại sẽ trả ra lỗi nếu số lượng giá trị của namedtuple lớn hơn số lượng giá trị của phần tử namedtuple đầu tiên. Ví dụ về cách tạo namedtuple from collections import namedtuple Point2D = namedtuple(&quot;Point2D&quot;, &quot;x y&quot;) Point3D = namedtuple(&quot;Point3D&quot;, &quot;x y z&quot;) Tạo DataFrame từ namedtuple Point2D In [1]: pd.DataFrame([Point2D(0, 0), Point2D(0, 1), Point2D(0, 2)]) Out[1]: x y 0 0 0 1 0 1 2 0 2 Tạo DataFrame từ namedtuple cả Point2D và Point3D In [1]: pd.DataFrame([Point3D(0, 0, 0), Point2D(0, 1), Point3D(0, 2, 3)]) Out[1]: x y z 0 0 0 0.0 1 0 1 NaN 2 0 2 3.0 Như ta thấy, tại phần tử thứ 2 chỉ có 2 giá trị, trong khi phần tử thứ nhất có 3 giá trị, vậy nên phần tử bị thiếu tại cột z sẽ được gán NaN Khởi tạo DataFrame từ Series In [1]: s = pd.Series(data=[0, 1, 2], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], name=&quot;meow&quot;) In [2]: pd.DataFrame(s) Out[2]: meow a 0 b 1 c 2 name của Series sẽ là tên cột của DataFrame và index của Series sẽ là index của DataFrame nếu ta không truyền các biến index, columns khi khởi tạo pd.DataFrame 1.2.2 Các hàm khởi tạo thay thế DataFrame.from_dict Cách khởi tạo pd.DataFrame.from_dict(data, orient=&#39;columns&#39;, dtype=None, columns=None) data truyền vào là 1 dict, orient có 2 giá trị có thể đưa vào là {\"columns\", \"index\"}, columns là danh sách tên các cột của DataFrame. Lưu ý: Chỉ được truyền columns khi orient=\"index\". Khi orient=\"columns\" sẽ báo lỗi. Ví dụ tạo DataFrame khi orient=\"columns\". Với cách khởi tạo này tên các cột của DataFrame sẽ là key của dict In [1]: data = {&quot;col_1&quot;: [3, 2, 1, 0], &quot;col_2&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]} In [2]: pd.DataFrame.from_dict(data) Out[2]: col_1 col_2 0 3 a 1 2 b 2 1 c 3 0 d Ví dụ tạo DataFrame khi orient=\"index\". Với cách khởi tạo này index của DataFrame sẽ là key của dict. In [1]: data = {&quot;col_1&quot;: [3, 2, 1, 0], &quot;col_2&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]} In [2]: pd.DataFrame.from_dict(data, orient=&quot;index&quot;, columns=[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]) Out[2]: col_1 col_2 0 3 a 1 2 b 2 1 c 3 0 d DataFrame.from_records Cách khởi tạo pd.DataFrame.from_records(data) data truyền vào có thể là một mảng có cấu trúc In [1]: data = np.array([(&#39;Rex&#39;, 9, 81.0), (&#39;Fido&#39;, 3, 27.0)], dtype=[(&#39;name&#39;, &#39;U10&#39;), (&#39;age&#39;, &#39;i4&#39;), (&#39;weight&#39;, &#39;f4&#39;)]) In [2]: pd.DataFrame.from_records(data, index=[&quot;a&quot;, &quot;b&quot;]) Out[2]: name age weight a Rex 9 81.0 b Fido 3 27.0 Dữ liệu có thể một danh sách các namedtuple from collections import namedtuple Point2D = namedtuple(&quot;Point2D&quot;, &quot;x y&quot;) Point3D = namedtuple(&quot;Point3D&quot;, &quot;x y z&quot;) pd.DataFrame.from_records([Point3D(0, 0, 0), Point2D(0, 1), Point3D(0, 2, 3)], columns=[&quot;x&quot;,&quot;y&quot;,&quot;z&quot;], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) x y z a 0 0 0.0 b 0 1 NaN c 0 2 3.0 Hoặc 1 danh sách các dict In [1]: d = [{&quot;one&quot;: 1, &quot;two&quot;: 2}, {&quot;one&quot;: 4, &quot;two&quot;: 5, &quot;three&quot;: 6}] In [2]: pd.DataFrame.from_records(d, index=[&quot;a&quot;, &quot;b&quot;], columns=[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]) Out[2]: one two three four a 1 2 NaN NaN b 4 5 6.0 NaN 1.3 Data type trong pandas Để kiểm tra kiểu dữ liệu của Series hay DataFrame bạn có thể gọi thuộc tính dtypes hoặc phương thức .info(). Các kiểu dữ liệu thường gặp của Pandas được mô tả theo bảng dưới đây: Các kiểu dữ liệu phổ biến Numpy/Pandas object Hiển thị Boolean np.bool bool Integer np.int, np.uint int uint Float np.float float Object np.object O, object Datetime np.datetime64, pd.Timestamp datetime64 Timedelta np.timedelta64, pd.Timedelta timedelta64 Category pd.Categorical category Complex np.complex complex Ví dụ: In [1]: df = pd.DataFrame({ &#39;col_1&#39;: [1, 0, 1, 0], &#39;col_2&#39;: [1.0, 2.0, 3.0, 4.0], &#39;col_3&#39;: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;], &#39;col_4&#39;: [&#39;1&#39;, 2, &#39;3&#39;, 4], &#39;col_5&#39;: [True, False, True, False], &#39;col_6&#39;: [&#39;2021-06-01&#39;, &#39;2021-06-02&#39;, &#39;2021-06-03&#39;, &#39;2021-06-04&#39;]}) In [2]: df Out[2]: col_1 col_2 col_3 col_4 col_5 col_6 0 1 1.0 1 1 True 2021-06-01 1 0 2.0 2 2 False 2021-06-02 2 1 3.0 3 3 True 2021-06-03 3 0 4.0 4 4 False 2021-06-04 In [3]: df.dtypes Out[3]: col_1 int64 col_2 float64 col_3 object col_4 object col_5 bool col_6 object dtype: object Lưu ý: Nếu không khai báo kiểu dữ liệu khi khởi tạo, pandas sẽ mặc định kiểu dữ liệu là int64, float64, object và bool. Pandas sẽ không biết kiểu dữ liệu timestamp nếu không khai báo. Chỉ có thể khai báo duy nhất 1 kiểu dữ liệu khi khởi tạo pandas. Ví dụ như tất cả dữ liệu của bạn là int hoặc có thể được ép kiểu về intthì có thể khai báo dtype=np.int Ở ví dụ phía dưới col_1, col_2, col_3, col_4, col_5 có thể ép về kiểu int, còn col_6 thì không thể ép kiểu được. In [1]: df = pd.DataFrame({ &#39;col_1&#39;: [1, 0, 1, 0], &#39;col_2&#39;: [1.0, 2.0, 3.0, 4.0], &#39;col_3&#39;: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;], &#39;col_4&#39;: [&#39;1&#39;, 2, &#39;3&#39;, 4], &#39;col_5&#39;: [True, False, True, False], &#39;col_6&#39;: [&#39;2021-06-01&#39;, &#39;2021-06-02&#39;, &#39;2021-06-03&#39;, &#39;2021-06-04&#39;]}, dtype=np.int) In [2]: df Out[2]: col_1 col_2 col_3 col_4 col_5 col_6 0 1 1 1 1 1 2021-06-01 1 0 2 2 2 0 2021-06-02 2 1 3 3 3 1 2021-06-03 3 0 4 4 4 0 2021-06-04 In [3]: df.dtypes Out[3]: col_1 int64 col_2 int64 col_3 object col_4 int64 col_5 int64 col_6 int64 dtype: object Mẹo: Nếu dữ liệu có khoảng nhỏ thì thay vì khai báo kiểu np.int, ta có thể khai báo kiểu integer với số byte phù hợp để giảm bộ nhớ lưu trữ. Để xem bộ nhớ sử dụng của DataFrame, ta có thể dùng .memory_usage(). Một số kiểu integer trong numpy như np.int8, np.int16, np.int32, np.int64, np.uint8, np.uint16, np.uint32, np.uint64 Theo ví dụ trên, khi dtype=np.int In [1]: df.memory_usage() Out[1]: Index 128 col_1 32 col_2 32 col_3 32 col_4 32 col_5 32 col_6 32 dtype: int64 và sau khi thay bằng dtype=np.int8 In [1]: df.memory_usage() Out[1]: Index 128 col_1 4 col_2 4 col_3 4 col_4 4 col_5 4 col_6 32 dtype: int64 Phương thức ép kiểu này được áp dụng khi bạn khởi tạo DataFrame, ngoài ra còn có hàm ép kiểu khác đối với DataFrame cho trước, nội dung này sẽ được đề cập ở Chương 3. "],["nhập-xuất-trong-pandas.html", "Chương 2 Nhập xuất trong pandas 2.1 Đọc và lưu file 2.2 Cấu hình pandas", " Chương 2 Nhập xuất trong pandas Ở Chương 1 chúng ta đã biết cách khởi tạo DataFrame từ các dữ liệu cho trước. Trong chương này sẽ hướng dẫn cách đọc dữ liệu từ file bằng pandas, một số kiểu file thường thấy cho dữ liệu dạng bảng là .csv và .xlsx. Bạn cũng có thể đọc dữ liệu bán cấu trúc như JSON bằng cách load file bằng Python sau đó dùng các cách khởi tạo như ở Chương 1 hoặc có thể dùng hàm phụ trợ của Pandas. Ở phần thứ hai của chương, bạn sẽ được hướng dẫn một số cách cấu hình cho Pandas như thay đổi số dòng, số cột hiển thị… 2.1 Đọc và lưu file 2.2 Cấu hình pandas "],["Chuong-3.html", "Chương 3 Một số hàm cơ bản", " Chương 3 Một số hàm cơ bản "],["lặp-trong-pandas.html", "Chương 4 Lặp trong Pandas 4.1 Sử dụng vectorizer 4.2 Sử dụng apply 4.3 Sử dụng iterator 4.4 Xử lý song song trong pandas", " Chương 4 Lặp trong Pandas 4.1 Sử dụng vectorizer 4.2 Sử dụng apply 4.3 Sử dụng iterator 4.4 Xử lý song song trong pandas "],["select-và-filter.html", "Chương 5 Select và Filter 5.1 Index 5.2 loc và iloc 5.3 Lọc theo điều kiện", " Chương 5 Select và Filter 5.1 Index 5.2 loc và iloc 5.3 Lọc theo điều kiện "],["các-cách-phối-hợp-nhiều-bảng-với-nhau.html", "Chương 6 Các cách phối hợp nhiều bảng với nhau 6.1 Join 6.2 Merge 6.3 Concat", " Chương 6 Các cách phối hợp nhiều bảng với nhau 6.1 Join 6.2 Merge 6.3 Concat "],["groupby-và-aggregate.html", "Chương 7 Groupby và Aggregate", " Chương 7 Groupby và Aggregate "],["làm-việc-với-1-số-kiểu-dữ-liệu.html", "Chương 8 Làm việc với 1 số kiểu dữ liệu 8.1 Xử lý dữ liệu dạng text 8.2 Xử lý dữ liệu dạng timestamp 8.3 Category trong pandas 8.4 Xử lý Missing data", " Chương 8 Làm việc với 1 số kiểu dữ liệu 8.1 Xử lý dữ liệu dạng text 8.2 Xử lý dữ liệu dạng timestamp 8.3 Category trong pandas 8.4 Xử lý Missing data "],["một-số-kiến-thức-nâng-cao.html", "Chương 9 Một số kiến thức nâng cao 9.1 MultiIndex 9.2 Pivot và Merge 9.3 Resample 9.4 Window", " Chương 9 Một số kiến thức nâng cao 9.1 MultiIndex 9.2 Pivot và Merge 9.3 Resample 9.4 Window "],["anomaly-detection-project.html", "Chương 10 Anomaly Detection Project", " Chương 10 Anomaly Detection Project "],["visualize-với-matplotlib.html", "Chương 11 Visualize với Matplotlib", " Chương 11 Visualize với Matplotlib "]]
